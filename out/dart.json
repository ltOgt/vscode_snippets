{
  "docstringTemplate": {
    "prefix": "docstringTemplate",
    "description": "docstringTemplate",
    "body": [
      "/// {@template $1}",
      "/// ...",
      "/// {@endtemplate}",
      "",
      "/// {@macro $1}"
    ]
  },
  "moor": {
    "prefix": "moor",
    "description": "moor",
    "body": [
      "// TODO add dependencies to pubspec.yaml",
      "// dependencies:",
      "//   # Fluent API for sqlite",
      "//   moor_flutter:",
      "//",
      "// dev_dependencies:",
      "//   # Generates the actual implementation of database specification",
      "//   moor_generator:",
      "//   # Provides commands for generating source files",
      "//   build_runner:",
      "",
      "import 'package:moor_flutter/moor_flutter.dart';",
      "",
      "// TODO run `flutter packages pub run build_runner [watch|build] --delete-conflicting-outputs`",
      "part 'moor_db.g.dart';",
      "",
      "// TODO rename database",
      "const String DATABASE_PATH = \"database.sqlite\";",
      "",
      "@UseMoor(tables: [",
      "  // TODO add tables (just the class name)",
      "], daos: [",
      "  // TODO add daos (just the class name)",
      "])",
      "class AppDatabase extends _$AppDatabase {",
      "  AppDatabase()",
      "      : super(",
      "          FlutterQueryExecutor.inDatabaseFolder(",
      "            path: DATABASE_PATH,",
      "            logStatements: true, // TODO remove, only for debugging",
      "          ),",
      "        ) {",
      "    this.customStatement(\"PRAGMA foreign_keys = ON\");",
      "  }",
      "",
      "  @override",
      "  int get schemaVersion => 1;",
      "",
      "  // @override",
      "  // MigrationStrategy get migration =>",
      "  //     MigrationStrategy(beforeOpen: (openingDetails) async {",
      "  //       if (true) {",
      "  //         final m = this.createMigrator(); // changed to this",
      "  //         for (final table in allTables) {",
      "  //           await m.deleteTable(table.actualTableName);",
      "  //           await m.createTable(table);",
      "  //         }",
      "  //       }",
      "  //     });",
      "}"
    ]
  },
  "proxyRenderObject": {
    "prefix": "proxyRenderObject",
    "description": "proxyRenderObject",
    "body": [
      "class $1 extends SingleChildRenderObjectWidget {",
      "  const $1({",
      "    Key? key,",
      "    Widget? child,",
      "  }) : super(key: key, child: child);",
      "",
      "  @override",
      "  Render$1 createRenderObject(BuildContext context) {",
      "    return Render$1();",
      "  }",
      "",
      "  @override",
      "  void updateRenderObject(BuildContext context, Render$1 renderObject) {",
      "    // TODO update via setters here",
      "  }",
      "}",
      "",
      "class Render$1 extends RenderProxyBox {",
      "  Render$1({",
      "    RenderBox? child,",
      "  }) : super(child);",
      "",
      "  // int _myvar;",
      "  // int get myvar => _myvar;",
      "  // set myvar(int value) {",
      "  //   if (value == _myvar) return;",
      "  //   assert(value > 0);",
      "  //   _myvar = value;",
      "  //   markNeedsLayout(); // or paint or parent ...",
      "  // }",
      "",
      "  @override",
      "  void paint(PaintingContext context, Offset offset) {",
      "    if (child != null) {",
      "      context.paintChild(child!, offset);",
      "    }",
      "  }",
      "}"
    ]
  },
  "mainDart": {
    "prefix": "mainDart",
    "description": "mainDart",
    "body": [
      "import 'package:flutter/material.dart';",
      "",
      "void main() {",
      "  runApp(const MyApp());",
      "}",
      "",
      "class MyApp extends StatelessWidget {",
      "  const MyApp({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return MaterialApp(",
      "      theme: ThemeData.dark(),",
      "      home: const Scaffold(",
      "        body: MyWidget(),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class MyWidget extends StatelessWidget {",
      "  const MyWidget({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Container();",
      "  }",
      "}"
    ]
  },
  "form": {
    "prefix": "form",
    "description": "form",
    "body": [
      "class _FormExampleState extends State<FormExample> {",
      "\tfinal _formKey = GlobalKey<FormState>();",
      "\tfinal _txtCtrl = TextEditingController();",
      "\t// ...",
      "",
      "\t@override",
      "\tWidget build(BuildContext context) {",
      "\t\treturn Form(",
      "\t\t\tkey: _formKey,",
      "\t\t\tchild: Column(",
      "\t\t\t\tchildren: [",
      "\t\t\t\t\t// ..",
      "\t\t\t\t\tTextFormField(",
      "\t\t\t\t\t\tcontroller: _txtCtrl,",
      "\t\t\t\t\t\tvalidator: (value) {",
      "\t\t\t\t\t\t\tif (value?.isEmpty ?? true) return \"Please Enter a Value\";",
      "\t\t\t\t\t\t\treturn null;",
      "\t\t\t\t\t\t},",
      "\t\t\t\t\t),",
      "\t\t\t\t\t// ..",
      "\t\t\t\t\tTextButton(",
      "\t\t\t\t\t\tchild: const Text(\"Submit\"),",
      "\t\t\t\t\t\tonPressed: () {",
      "\t\t\t\t\t\t\tif (!_formKey.currentState!.validate()) return;",
      "",
      "\t\t\t\t\t\t\tdoSomethingWithValues(_txtCtrl.value, ...);",
      "\t\t\t\t\t\t},",
      "\t\t\t\t\t),",
      "\t\t\t\t],",
      "\t\t\t),",
      "\t\t);",
      "\t}",
      "}",
      ""
    ]
  },
  "get_http_html": {
    "prefix": "get_http_html",
    "description": "get_http_html",
    "body": [
      "import 'package:html/parser.dart' as parser;",
      "import 'package:html/dom.dart' as dom;",
      "import 'package:http/http.dart' as http;",
      "",
      "http.Response? _response;",
      "dom.Document? _html;",
      "",
      "_response = await http.get(Uri.https(\"google.com\", \"\", {'q': _query.obj.text}));",
      "",
      "if (_response!.statusCode == 200) {",
      "  _html = parser.parse(_response!.body);",
      "}"
    ]
  },
  "equalsCollection": {
    "prefix": "equalsCollection",
    "description": "equalsCollection",
    "body": [
      "import 'package:collection/collection.dart';",
      "final listEquals = const DeepCollectionEquality().equals;",
      "final listHash = const DeepCollectionEquality().hash"
    ]
  },
  "leafRenderObject": {
    "prefix": "leafRenderObject",
    "description": "leafRenderObject",
    "body": [
      "class $1 extends LeafRenderObjectWidget {",
      "  const $1({",
      "    Key? key,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  RenderObject createRenderObject(BuildContext context) {",
      "    return Render$1();",
      "  }",
      "",
      "  @override",
      "  void updateRenderObject(",
      "    BuildContext context,",
      "    Render$1 renderObject,",
      "  ) {",
      "    // TODO use setters here",
      "  }",
      "}",
      "",
      "class Render$1 extends RenderBox {",
      "  Render$1();",
      "",
      "  // int _myvar;",
      "  // int get myvar => _myvar;",
      "  // set myvar(int value) {",
      "  //   if (value == _myvar) return;",
      "  //   assert(value > 0);",
      "  //   _myvar = value;",
      "  //   markNeedsLayout();",
      "  // }",
      "",
      "  @override",
      "  Size computeDryLayout(BoxConstraints constraints) {",
      "    // TODO compute dry layout",
      "    return constraints.smallest;",
      "  }",
      "",
      "  @override",
      "  void performLayout() {",
      "    // TODO: implement performLayout",
      "    size = constraints.smallest;",
      "  }",
      "",
      "  @override",
      "  void paint(PaintingContext context, Offset offset) {",
      "    // TODO: implement paint",
      "  }",
      "}"
    ]
  },
  "fab": {
    "prefix": "fab",
    "description": "fab",
    "body": [
      "FloatingActionButton(",
      "  onPressed: () {},",
      "  child: const Icon(Icons.add),",
      ")"
    ]
  },
  "getset": {
    "prefix": "getset",
    "description": "getset",
    "body": [
      "// 1: type, 2: name",
      "$1 _$2;",
      "$1 get $2 => _$2;",
      "set $2($1 v) => notify(() => _$2 = v);"
    ]
  },
  "fori": {
    "prefix": "fori",
    "description": "fori",
    "body": [
      "for (int i=0; i < $1.length; i++) {final item = $1[i];}"
    ]
  },
  "req": {
    "prefix": "req",
    "description": "req",
    "body": [
      "@required"
    ]
  },
  "test": {
    "prefix": "test",
    "description": "test",
    "body": [
      "import 'package:test/test.dart';",
      "import 'package:flutter_test/flutter_test.dart';",
      "",
      "void main() {",
      "  group('Class', () {",
      "    test('throws', () async {",
      "      expect(() => throw Exception(), throwsA(isA<Exception>()));",
      "    });",
      "    test('does not throw', () async {",
      "      expect(() => 5, returnsNormally);",
      "    });",
      "",
      "\t\ttestWidgets(\"widget\", (tester) async {",
      "      await tester.pumpWidget(Container());",
      "\t\t\tawait tester.pumpAndSettle();",
      "\t\t\tawait tester.binding.setSurfaceSize(kScreenSize);",
      "\t\t\tawait tester.drag(find.byKey(dragKey), moveByOffset);",
      "    });",
      "  });",
      "}"
    ]
  },
  "cmdBase": {
    "prefix": "cmdBase",
    "description": "cmdBase",
    "body": [
      "import 'package:flutter/widgets.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "/// ========================================================= base command file",
      "",
      "/// See [SetupWidget].",
      "class BaseCommand {",
      "  static BuildContext? _rootContext;",
      "  static BuildContext get rootContext {",
      "    assert(",
      "      _rootContext != null,",
      "      \"BaseCommand._rootContext not initialized. Did you forget to call BaseCommand.init(context) ,at the top of your application?\"",
      "    );",
      "    return _rootContext!;",
      "\t}",
      "",
      "  static void init(BuildContext rootContext) {",
      "    BaseCommand._rootContext ??= rootContext;",
      "  }",
      "",
      "  MyModel get myModel => rootContext.read();",
      "}",
      "",
      "/// Initializes [BaseCommand] and all of your models",
      "///",
      "/// Put this somewhere high in your application tree",
      "/// E.g. `runApp(const SetupWidget(child: MyApp()));`",
      "class SetupWidget extends StatelessWidget {",
      "  const SetupWidget({",
      "    Key? key,",
      "    required this.child,",
      "  }) : super(key: key);",
      "",
      "  final Widget child;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return MultiProvider(",
      "      providers: [",
      "        ChangeNotifierProvider<MyModel>(",
      "          lazy: false,",
      "          create: (context) => MyModel(),",
      "        ),",
      "        // TODO add other models here as needed",
      "      ],",
      "      builder: (context, child) {",
      "        // Called every time, but only has a side effect on first call",
      "        BaseCommand.init(context);",
      "        return child!;",
      "      },",
      "      child: child,",
      "    );",
      "  }",
      "}",
      "",
      "/// ========================================================= one of the actual command files",
      "",
      "class CanvasSelectionCmd extends BaseCommand {",
      "  /// Change the selection of the canvas",
      "  void run() async {",
      "    myModel.update(myValue: (i) => i++);",
      "  }",
      "}",
      "",
      "/// ========================================================= one of the model files",
      "",
      "typedef Updater<T> = T Function(T current);",
      "",
      "class MyModel extends ChangeNotifier {",
      "  int _myValue = 0;",
      "",
      "  /// Update a set of values of the model",
      "  void update({",
      "    Updater<int>? myValue,",
      "  }) {",
      "    bool anyChanged = false;",
      "    void change<T>(T current, Updater<T>? update, void Function(T) apply) {",
      "      if (update != null) {",
      "        apply(update(current));",
      "        anyChanged = true;",
      "      }",
      "    }",
      "",
      "    /// TODO add values here as needed",
      "    change(_myValue, myValue, (v) => _myValue = v);",
      "",
      "    if (anyChanged) notifyListeners();",
      "  }",
      "}"
    ]
  },
  "canvas": {
    "prefix": "canvas",
    "description": "canvas",
    "body": [
      "import 'dart:collection';",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:relation_canvas/relation_canvas.dart';",
      "",
      "void main() {",
      "  runApp(const MyApp());",
      "}",
      "",
      "class MyApp extends StatelessWidget {",
      "  const MyApp({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return MaterialApp(",
      "      theme: ThemeData.dark(),",
      "      home: const MyCanvas(),",
      "    );",
      "  }",
      "}",
      "",
      "class MyCanvas extends StatefulWidget {",
      "  const MyCanvas({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<MyCanvas> createState() => _MyCanvasState();",
      "}",
      "",
      "class CanvasModel extends ChangeNotifier {",
      "  final Map<CanvasRelationId, CanvasRelation> _relations = {};",
      "  final Map<CanvasNodeId, CanvasNode> _nodes = {};",
      "  final Map<CanvasExternalId, CanvasExternal> _externals = {};",
      "",
      "  /// - [update] receives null     <-- [id] was not found in [_nodes].",
      "  /// - [update] returns null      --> node behind [id] will not be changed",
      "  ///                              --> node behind [id] will not be removed. use [removeNode] instead.",
      "  /// - [update] returns a node    --> node behind [id] will be replaced.",
      "  void _updateMap<K, V>(Map<K, V> map, K id, V? Function(V? node) update) {",
      "    final value = map[id];",
      "    final updated = update(value);",
      "    if (updated != null) {",
      "      map[id] = updated;",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  V? _removeMap<K, V>(Map<K, V> map, K key) {",
      "    final removed = map.remove(key);",
      "    notifyListeners();",
      "    return removed;",
      "  }",
      "",
      "  void updateNode(CanvasNodeId id, CanvasNode? Function(CanvasNode? node) update) => _updateMap(_nodes, id, update);",
      "  void updateRelations(CanvasRelationId id, CanvasRelation? Function(CanvasRelation? node) update) =>",
      "      _updateMap(_relations, id, update);",
      "  void updateExternals(CanvasExternalId id, CanvasExternal? Function(CanvasExternal? node) update) =>",
      "      _updateMap(_externals, id, update);",
      "  CanvasNode? removeNode(CanvasNodeId id) => _removeMap(_nodes, id);",
      "  CanvasRelation? removeRelations(CanvasRelationId id) => _removeMap(_relations, id);",
      "  CanvasExternal? removeExternals(CanvasExternalId id) => _removeMap(_externals, id);",
      "",
      "  ReadOnlyMap<CanvasRelationId, CanvasRelation> get relations => _relations.readOnly;",
      "  ReadOnlyMap<CanvasNodeId, CanvasNode> get nodes => _nodes.readOnly;",
      "  ReadOnlyMap<CanvasExternalId, CanvasExternal> get externals => _externals.readOnly;",
      "}",
      "",
      "class _MyCanvasState extends ComponentState<MyCanvas> {",
      "  // =========================================================================== Canvas Settings",
      "  final CanvasSettings canvasSettings = CanvasSettings.uniform(10000);",
      "",
      "  // =========================================================================== Controller Setup",
      "  late final RelationCanvasStateComponent ctrl;",
      "  void initCtrl() => ctrl = RelationCanvasStateComponent(",
      "        state: this,",
      "        canvasSettings: canvasSettings,",
      "      );",
      "",
      "  CanvasModel get canvasModel => _scCanvasModel.value;",
      "  late final StateComponent<CanvasModel> _scCanvasModel;",
      "  void initModel() => _scCanvasModel = StateComponent(",
      "        onInit: () => CanvasModel(),",
      "        onDispose: (_) {},",
      "        state: this,",
      "        setStateOnChange: true,",
      "        onChange: () {},",
      "      );",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "",
      "    initCtrl();",
      "    initModel();",
      "  }",
      "",
      "  final CircleIdGen idGen = CircleIdGen();",
      "",
      "  Set<CanvasNodeId> selected = {};",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Scaffold(",
      "      backgroundColor: Colors.black,",
      "      floatingActionButton: FloatingActionButton(",
      "        onPressed: createNewNodeInViewportCenter,",
      "      ),",
      "      body: RelationCanvas(",
      "        relations: canvasModel.relations,",
      "        nodeCanvasParameters: NodeCanvasParameters(",
      "",
      "            /// Set-Up",
      "            referenceFrameController: ctrl.referenceFrameController,",
      "            nodeCanvasController: ctrl.nodeCanvasController,",
      "            backgroundColor: Colors.blueGrey.shade900,",
      "",
      "            /// Transformation options for nodes",
      "            nodes: canvasModel.nodes,",
      "            nodeOptions: NodeOptionsNC(",
      "              moveables: {...canvasModel.nodes.keys},",
      "              scalables: {...canvasModel.nodes.keys},",
      "              onEnd: (data) {",
      "                final single = data.asSingle;",
      "                if (single != null) {",
      "                  canvasModel.updateNode(",
      "                    single.nodeId,",
      "                    (node) => node?.copyWith(",
      "                      rect: single.currentRect,",
      "                    ),",
      "                  );",
      "                } else {",
      "                  final group = data.asGroup!;",
      "                  // Transform group",
      "                  for (final member in group.memberRects.entries) {",
      "                    canvasModel.updateNode(",
      "                      member.key,",
      "                      (node) => node?.copyWith(",
      "                        rect: member.value,",
      "                      ),",
      "                    );",
      "                  }",
      "                }",
      "              },",
      "            ),",
      "",
      "            /// External UI elements that should be in [ordering] or",
      "            /// placed relatively via [externalPlacementOptions].",
      "            ///",
      "            /// [externals] placed via [externalPlacementOptions] will be",
      "            /// automatically removed from [ordering].",
      "            externals: canvasModel.externals,",
      "            externalPlacementOptions: const ExternalPlacementOptionsNC(),",
      "",
      "            /// Ordering of all canvas elements",
      "            ordering: {",
      "              ...canvasModel.nodes.keys,",
      "              ...canvasModel.relations.keys,",
      "              ...canvasModel.externals.keys,",
      "            } as LinkedHashSet<CanvasElementId>,",
      "",
      "            /// Groups of [CanvasNodeId]s that can be transformed together",
      "            groups: {",
      "              if (selected.isNotEmpty)",
      "                CanvasGroup(",
      "                  members: selected,",
      "                  isMoveable: true,",
      "                  isScalable: true,",
      "                  placement: PlacementCanvasGroup.belowMembers,",
      "                  color: Colors.white.withAlpha(100),",
      "                ),",
      "            },",
      "",
      "            /// Selection boxes",
      "            selectionOptions: SelectionOptionsNC(",
      "              // TODO ---------------- this is not currently called after transform => changed selection",
      "              onSelectionChange: (areas) {",
      "                // do stuff with rect intersection",
      "                setState(() {",
      "                  selected = canvasModel.nodes.values",
      "                      .where((n) => areas.fold(false, (acc, sRect) => acc || sRect.overlaps(n.rect)))",
      "                      .map((e) => e.id)",
      "                      .toSet();",
      "                });",
      "              },",
      "            ),",
      "",
      "            /// Canvas Tap Callback",
      "            onTapCanvas: (details) {",
      "              final OffsetCanvas co = ctrl.rfc.offsetCanvasTLToCanvas(",
      "                OffsetCanvasTL.fromOffset(details.localPosition),",
      "              );",
      "              print(\\\"Tapped the canvas at ${co.toValueString()}\\\");",
      "",
      "              /// Clear selection",
      "              ctrl.ncCtrl.clearSelection();",
      "            },",
      "",
      "            /// Widget to put as background",
      "            backgroundWidget: const DecoratedBox(",
      "              decoration: BoxDecoration(",
      "                gradient: RadialGradient(",
      "                  colors: [",
      "                    Color(0xFF444444),",
      "                    Color(0xFF333333),",
      "                    Color(0xFF222222),",
      "                    Color(0xFF000000),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "",
      "            /// Ruler Options",
      "            rulerOptions: const RulerOptions(",
      "              color: Colors.transparent,",
      "              width: 1,",
      "            )),",
      "      ),",
      "    );",
      "  }",
      "",
      "  void createNewNodeInViewportCenter() {",
      "    final id = CanvasNodeId.decode(idGen.next.value);",
      "    final viewportRect = ctrl.rfc.viewportAsCanvasRect;",
      "",
      "    canvasModel.updateNode(",
      "      id,",
      "      (node) => CanvasNode(",
      "        id: id,",
      "        rect: viewportRect.shrink(viewportRect.smallSide / 4),",
      "        builder: CanvasElementCachelessBuilder(builder: (context, lod) {",
      "          return Container(color: Colors.blue);",
      "        }),",
      "      ),",
      "    );",
      "  }",
      "}"
    ]
  },
  "containerDecorated": {
    "prefix": "containerDecorated",
    "description": "containerDecorated",
    "body": [
      "Container(",
      "  decoration: BoxDecoration(",
      "    //color: Colors.white,",
      "    //border: Border(top: BorderSide(color: Colors.blueAccent))",
      "    //border: Border.all(color: Colors.blueAccent),",
      "    //borderRadius: BorderRadius.only(topLeft: const Radius.circular(4.0)),",
      "    //borderRadius: BorderRadius.all(const Radius.circular(4.0)),",
      "    //boxShadow: [BoxShadow(color: Colors.black, blurRadius: 1, spreadRadius: 1, offset: Offset(1,1))],",
      "    //shape: BoxShape.circle,",
      "  ),",
      "  child: SizedBox(),",
      ")"
    ]
  },
  "enum_next": {
    "prefix": "enum_next",
    "description": "enum_next",
    "body": [
      "$1 get next => $1.values[(index + 1) % $1.values.length];"
    ]
  }
}